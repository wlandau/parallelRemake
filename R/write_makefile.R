#' @title Function \code{collate_remakefiles}
#' @description Collate multiple \code{remake}/\code{YAML} files 
#' into a single \code{remake}/\code{YAML} file if necessary.
#' @return Name of the collated (or solitary) \code{remake}/\code{YAML} file
#' @param remakefiles names/paths of the \code{remake}/\code{YAML} files.
collate_remakefiles = function(remakefiles){
  remakefiles = unique(remakefiles)
  if(length(remakefiles) > 1 || length(yaml_read(remakefiles[1])$include) > 0){
    remakefile = collate_yaml(remakefiles)
  } else {
    remakefile = remakefiles
  }
  remakefile
}

#' @title Function \code{makefile_clean}
#' @description Write the rules of the Makefile for cleaning up
#' @param remakefile name of the (collated) \code{remake}/\code{YAML} file
#' @param clean character vector of extra lines to run on \code{make clean}.
#' @param add_args extra arguments to add to \code{remake}
makefile_clean = function(remakefile, clean, add_args){
  cat("clean:\n\tRscript -e \'remake::make(\"clean\", remake_file = \"", 
          remakefile, "\"", add_args, ")\'\n", sep = "")
  cat("\trm -rf .remake\n")
  for(rule in clean) cat("\t", str_trim(rule), "\n", sep = "")
}

#' @title Function \code{makefile_head}
#' @description Print the top lines of the Makefile (prepended lines and phony targets).
#' @param begin character vector of lines to prepend to the Makefile
#' @param targets \code{YAML}-like list of Makefile targets
makefile_head = function(begin, targets){
  cat("# Generated by parallelRemake::write_makefile() on", as.character(Sys.time()), "\n\n")
  if(!is.null(begin)){
    cat(begin, sep = "\n")
    cat("\n")
  }
  cat(".PHONY:", names(targets), "clean\n\n")
}

#' @title Function \code{makefile_rules}
#' @description Write the rules of the Makefile for pseudo-making the targets
#' @param remakefile name of the (collated) \code{remake}/\code{YAML} file
#' @param targets \code{YAML}-like list of Makefile targets
#' @param add_args extra arguments to add to \code{remake}
makefile_rules = function(remakefile, targets, add_args){
  for(name in names(targets)){
    cat(name, ": ", sep = "")
    target = targets[[name]]
    dep = unique(c(unlist(target$depends), parse_command(target$command)$depends))
    dep = dep[dep != "target_name"] # "target_name" is a keyword in remake.
    cat(dep, "\n")
    if("command" %in% names(target) | !is.null(target$knitr)){
      cat("\tRscript -e \'remake::make(\"", name, "\", remake_file = \"", 
          remakefile, "\"", add_args, ")\'\n", sep = "")
    }
    cat("\n")
  }
}

#' @title Function \code{write_makefile}
#' @description Writes a master Makefile that can distribute \code{remake} workflows
#' over simultaneous processes.
#' @export
#' @param makefile Name of the Makefile to write.
#' @param remakefiles Character vector of paths to input \code{remake} files.
#' @param begin Character vector of lines to prepend to the Makefile.
#' @param clean Character vector of commands to add to the \code{clean} rule.
#' @param remake_args Named list of additional arguments to \code{remake::make}.
#' You cannot set \code{target_names} or \code{remake_file} this way because 
#' those names are already reserved.
write_makefile = function(makefile = "Makefile", remakefiles = "remake.yml", 
  begin = NULL, clean = NULL, remake_args = list()){

  add_args = remake_args(remake_args)
  remakefile = collate_remakefiles(remakefiles)
  remake_data = yaml_read(remakefile)
  targets = remake_data$targets

  sink(makefile)
  makefile_head(begin, targets)
  makefile_rules(remakefile, targets, add_args)
  makefile_clean(remakefile, clean, add_args)
  sink()
}
